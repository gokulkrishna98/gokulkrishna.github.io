<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Conanicalization ðŸ’£ | Gokul's Website</title>
<meta name=keywords content><meta name=description content="This article summarizes my understanding of canonical forms from the perspective of intermediate representation (compilers). We also go through how we can use MLIR pattern rewrite to implement canonicalization of operations.
What is Canonicalization ?
It is a process which converts data (that can have one more possible representation) into a &lsquo;standard&rsquo;, &rsquo;normal&rsquo; or &lsquo;canonical form&rsquo;. We can visualize the data through simple arithmetic expression which can have multiple forms:"><meta name=author content="Gokul"><link rel=canonical href=http://localhost:1313/posts/canonicalization/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/canonicalization/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/canonicalization/"><meta property="og:site_name" content="Gokul's Website"><meta property="og:title" content="Conanicalization ðŸ’£"><meta property="og:description" content="This article summarizes my understanding of canonical forms from the perspective of intermediate representation (compilers). We also go through how we can use MLIR pattern rewrite to implement canonicalization of operations.
What is Canonicalization ? It is a process which converts data (that can have one more possible representation) into a â€˜standardâ€™, â€™normalâ€™ or â€˜canonical formâ€™. We can visualize the data through simple arithmetic expression which can have multiple forms:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-25T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-25T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Conanicalization ðŸ’£"><meta name=twitter:description content="This article summarizes my understanding of canonical forms from the perspective of intermediate representation (compilers). We also go through how we can use MLIR pattern rewrite to implement canonicalization of operations.
What is Canonicalization ?
It is a process which converts data (that can have one more possible representation) into a &lsquo;standard&rsquo;, &rsquo;normal&rsquo; or &lsquo;canonical form&rsquo;. We can visualize the data through simple arithmetic expression which can have multiple forms:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Conanicalization ðŸ’£","item":"http://localhost:1313/posts/canonicalization/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Conanicalization ðŸ’£","name":"Conanicalization ðŸ’£","description":"This article summarizes my understanding of canonical forms from the perspective of intermediate representation (compilers). We also go through how we can use MLIR pattern rewrite to implement canonicalization of operations.\nWhat is Canonicalization ? It is a process which converts data (that can have one more possible representation) into a \u0026lsquo;standard\u0026rsquo;, \u0026rsquo;normal\u0026rsquo; or \u0026lsquo;canonical form\u0026rsquo;. We can visualize the data through simple arithmetic expression which can have multiple forms:\n","keywords":[],"articleBody":"This article summarizes my understanding of canonical forms from the perspective of intermediate representation (compilers). We also go through how we can use MLIR pattern rewrite to implement canonicalization of operations.\nWhat is Canonicalization ? It is a process which converts data (that can have one more possible representation) into a â€˜standardâ€™, â€™normalâ€™ or â€˜canonical formâ€™. We can visualize the data through simple arithmetic expression which can have multiple forms:\nx + 9 x + 5 + 4 3*3 + x (1 \u003c\u003c 3) + 1 + x Canonicalization is essentially means picking one of these forms to be canonical form, then convert all the other ways to write the expression in the program to this canonical form.\nThe goal of canonicalization is to make future optimization easier to implement. This helps compiler to not worry about expression with different forms. Imagine, we have a optimization involving the expression x + 9, we can just look for the canonical form of this expression after canonicalization, instead of worry about all the equivalent forms.\nHow do we Choose Canonical Forms ? This is primary function of Canonicalization. There are lot of reasons one may prefer one form over another, they can be:\nIt results in simple and concise representation (its natural to be in this form). 8 is the canonical form of 5+3, 1\u003c\u003c3, 2*2*2 because its natural simple and efficient. Some forms are chosen for human aesthetics. I prefer x + 3 over 3 + x. Sometimes the chosen form is fast or optimal on a target machine (for example the first reason results in faster form). There are lot of trade-offs between different factors. Like Don Gohman described: What is more useful 2*x or x + x ?\n\" â€¦ x * 2 is equivalent to x + x; which of these should be the canonical form? It might seem like we might want to say: pick whateverâ€™s optimal for the target architecture. Addition is generally faster than multiplication, so that would suggest we pick x + x as the canonical form. But, x + x can actually make things harder for subsequent optimizations, because it means that now x has multiple uses. Having multiple uses makes some optimizations more complex â€“ in terms of the dependence graph, this is a DAG rather than a tree, and trees are generally simpler to work with. So maybe x * 2 is actually a better canonical form, even if itâ€™s a worse optimal form. â€¦.. But ultimately, in its purest form, canonicalization just focuses on removing unnecessary variation so that subsequent optimizations can be simpler.\"\nSo, the goal of the canonicalization is not to convert expression into optimal form, but choose a form which makes the work of the back-end of the compiler simpler. The back-end of the compilerâ€™s job would be convert these canonical forms to optimal forms for the target machine.\nDon Gohman discusses nuanced topics like : redundancy, inlining, excessive canonicalization and compression (read it here).\nNow let us see how we can implement canonicalization of operation using MLIR rewrite patterns\nImplementing Canonicalization using MLIR Pattern Rewrite This is mainly my implementation of pattern rewrite using tablegen declarative way based of toy chapter 3. You could find the implementation details via this commit: here\nReshape Operation Definition:\ndef ReshapeOp : GGlowOp \u003c\"reshape\", [Pure]\u003e { let summary = \"reshape operation\"; let description = [{ Reshape operation is transforming its input tensor into a new tensor with the same number of elements but different shapes. For example: %0 = gglow.reshape (%arg1 : tensor\u003c10xf64\u003e) -\u003e tensor\u003c5x2xf64\u003e }]; let arguments = (ins F64Tensor:$input); let results = (outs StaticShapeTensorOf\u003c[F64]\u003e); let assemblyFormat = [{ `(` $input `:` type($input) attr-dict `)` `-\u003e` type(results) }]; let hasCanonicalizer = 1; } The let hasCanonicalizer provides us hook C++ API to register our Tablegen declared optimization and enable it.\nLet us consider the reshape operation. This basically takes in a tensor and reshapes into a specific fixed shape (not given as argument to the operation). So, we have following properties like:\nReshape(Reshape(x)) = Reshape(x). We can remove reshape if input tensor and output tensor reshapes are same. Constant Operation -\u003e Reshape can be equivalent to Modified Constant Operation We can write these patterns via rule based dag approach, defined in PatternBase.td. In this example we use a simplified construct called Pat which is defined as:\nclass Pat\u003c dag sourcePattern, dag resultPattern, list\u003cdag\u003e additionalConstraints = [], dag benefitsAdded = (addBenefit 0)\u003e : Pattern","wordCount":"1122","inLanguage":"en","datePublished":"2024-08-25T00:00:00Z","dateModified":"2024-08-25T00:00:00Z","author":{"@type":"Person","name":"Gokul"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/canonicalization/"},"publisher":{"@type":"Organization","name":"Gokul's Website","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Gokul's Website (Alt + H)">Gokul's Website</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;Â»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Conanicalization ðŸ’£</h1><div class=post-meta><span title='2024-08-25 00:00:00 +0000 UTC'>August 25, 2024</span>&nbsp;Â·&nbsp;6 min&nbsp;Â·&nbsp;1122 words&nbsp;Â·&nbsp;Gokul</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents></nav></div></details></div><div class=post-content><p>This article summarizes my understanding of canonical forms from the perspective of intermediate representation (compilers). We also go through how we can use MLIR pattern rewrite to implement canonicalization of operations.</p><h1 id=what-is-canonicalization->What is Canonicalization ?<a hidden class=anchor aria-hidden=true href=#what-is-canonicalization->#</a></h1><p>It is a process which converts data (that can have one more possible representation) into a &lsquo;standard&rsquo;, &rsquo;normal&rsquo; or &lsquo;canonical form&rsquo;. We can visualize the data through simple arithmetic expression which can have multiple forms:</p><pre tabindex=0><code>x + 9
x + 5 + 4
3*3 + x
(1 &lt;&lt; 3) + 1 + x
</code></pre><p>Canonicalization is essentially means picking one of these forms to be canonical form, then convert all the other ways to write the expression in the program to this canonical form.</p><p>The goal of canonicalization is to make future optimization easier to implement. This helps compiler to not worry about expression with different forms. Imagine, we have a optimization involving the expression <code>x + 9</code>, we can just look for the canonical form of this expression after canonicalization, instead of worry about all the equivalent forms.</p><h1 id=how-do-we-choose-canonical-forms->How do we Choose Canonical Forms ?<a hidden class=anchor aria-hidden=true href=#how-do-we-choose-canonical-forms->#</a></h1><p>This is primary function of Canonicalization. There are lot of reasons one may prefer one form over another, they can be:</p><ul><li>It results in simple and concise representation (its natural to be in this form). <code>8</code> is the canonical form of <code>5+3</code>, <code>1&lt;&lt;3</code>, <code>2*2*2</code> because its natural simple and efficient.</li><li>Some forms are chosen for human aesthetics. I prefer <code>x + 3</code> over <code>3 + x</code>.</li><li>Sometimes the chosen form is fast or optimal on a target machine (for example the first reason results in faster form).</li></ul><p>There are lot of trade-offs between different factors. Like Don Gohman described: What is more useful <code>2*x</code> or <code>x + x</code> ?</p><blockquote><p>" &mldr; <code>x * 2</code> is equivalent to <code>x + x</code>; which of these should be the canonical form? It might seem like we might want to say: pick whateverâ€™s optimal for the target architecture. Addition is generally faster than multiplication, so that would suggest we pick <code>x + x</code> as the canonical form. But, <code>x + x</code> can actually make things harder for subsequent optimizations, because it means that now <code>x</code> has multiple uses. Having multiple uses makes some optimizations more complex â€“ in terms of the dependence graph, this is a DAG rather than a tree, and trees are generally simpler to work with. So maybe <code>x * 2</code> is actually a better canonical form, even if itâ€™s a worse optimal form. &mldr;.. But ultimately, in its purest form, canonicalization just focuses on removing unnecessary variation so that subsequent optimizations can be simpler."</p></blockquote><p>So, the goal of the canonicalization is not to convert expression into optimal form, but choose a form which makes the work of the back-end of the compiler simpler. The back-end of the compiler&rsquo;s job would be convert these canonical forms to optimal forms for the target machine.</p><p>Don Gohman discusses nuanced topics like : redundancy, inlining, excessive canonicalization and compression (read it <a href=https://sunfishcode.github.io/blog/2018/10/22/Canonicalization.html>here</a>).</p><p>Now let us see how we can implement canonicalization of operation using MLIR rewrite patterns</p><h1 id=implementing-canonicalization-using-mlir-pattern-rewrite>Implementing Canonicalization using MLIR Pattern Rewrite<a hidden class=anchor aria-hidden=true href=#implementing-canonicalization-using-mlir-pattern-rewrite>#</a></h1><p>This is mainly my implementation of pattern rewrite using tablegen declarative way based of toy chapter 3. You could find the implementation details via this commit: <a href=https://github.com/gokulkrishna98/GGlow/commit/4890bb79cbda8090a315f21e95aa778da620748a>here</a></p><p>Reshape Operation Definition:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tablegen data-lang=tablegen><span style=display:flex><span><span style=color:#66d9ef>def</span> ReshapeOp : GGlowOp &lt;<span style=color:#e6db74>&#34;reshape&#34;</span>, [Pure]&gt; {
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> summary = <span style=color:#e6db74>&#34;reshape operation&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> description = <span style=color:#e6db74>[{
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	Reshape operation is transforming its input tensor into a new tensor
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	with the same number of elements but different shapes. For example:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	%0 = gglow.reshape (%arg1 : tensor&lt;10xf64&gt;) -&gt; tensor&lt;5x2xf64&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}]</span>;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> arguments = (ins F64Tensor:$input);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> results = (outs StaticShapeTensorOf&lt;[F64]&gt;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> assemblyFormat = <span style=color:#e6db74>[{
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	`(` $input `:` type($input) attr-dict `)` `-&gt;` type(results)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}]</span>;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> hasCanonicalizer = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>let hasCanonicalizer</code> provides us hook C++ API to register our Tablegen declared optimization and enable it.</p><p>Let us consider the reshape operation. This basically takes in a tensor and reshapes into a specific fixed shape (not given as argument to the operation). So, we have following properties like:</p><ul><li>Reshape(Reshape(x)) = Reshape(x).</li><li>We can remove reshape if input tensor and output tensor reshapes are same.</li><li>Constant Operation -> Reshape can be equivalent to Modified Constant Operation</li></ul><p>We can write these patterns via rule based dag approach, defined in <code>PatternBase.td</code>. In this example we use a simplified construct called <code>Pat</code> which is defined as:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tablegen data-lang=tablegen><span style=display:flex><span><span style=color:#66d9ef>class</span> Pat&lt;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>dag</span> sourcePattern, <span style=color:#66d9ef>dag</span> resultPattern,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>list</span>&lt;<span style=color:#66d9ef>dag</span>&gt; additionalConstraints = [],
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>dag</span> benefitsAdded = (addBenefit <span style=color:#ae81ff>0</span>)&gt; :
</span></span><span style=display:flex><span>	  Pattern&lt;sourcePattern, [resultPattern], additionalConstraints, 
</span></span><span style=display:flex><span>	  benefitAdded&gt;;
</span></span></code></pre></div><p>Each pattern is specified as a TableGen <code>dag</code> object with the syntax of <code>(operator arg0, arg1, ...)</code>. The operator can be Operations and directives (like replaceWithValue, Constraints etc )</p><p>We provide the following information:</p><ul><li><code>sourcePattern</code> : It finds this dag pattern in IR and tries to replace it with <code>resultPattern</code>.</li><li><code>resultPattern</code>: The dag canonical form of the operation.</li><li><code>additionalConstraints</code>: list of dag (formed via constraint definition) that provides additional constraints which it must satisfy to use this pattern transformation.</li><li><code>benefits added</code>: It is kind of priority value. If multiple patterns match for an operation, use the one higher benefit value. Default value is 0.</li></ul><p>Let see how we implement these three using Table gen:</p><ol><li>Reshape(Reshape(x)) = Reshape(x)</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tablegen data-lang=tablegen><span style=display:flex><span><span style=color:#66d9ef>def</span> ReshapeReshapeOptPattern : Pat&lt;(ReshapeOp(ReshapeOp $arg)), (ReshapeOp $arg)&gt;;
</span></span></code></pre></div><ol start=2><li>If Reshape(x) = x, then remove Reshape Operation. We first check if input and output shapes are same (by checking type equivalence of tensor dialect). Then add it as constraint to our Pat. We replace the operation with argument value.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tablegen data-lang=tablegen><span style=display:flex><span><span style=color:#66d9ef>def</span> TypesIdentical : Constraint&lt;CPred&lt;<span style=color:#e6db74>&#34;$0.getType() == $1.getType()&#34;</span>&gt;&gt;;
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> RedundantReshapeOptPattern : 
</span></span><span style=display:flex><span>	Pat &lt;(ReshapeOp:$res $arg),(replaceWithValue $arg),
</span></span><span style=display:flex><span>		[(TypesIdentical $res, $arg)]&gt;;
</span></span></code></pre></div><ol start=3><li>Constant Operation -> Reshape can be equivalent to Modified Constant Operation.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tablegen data-lang=tablegen><span style=display:flex><span><span style=color:#66d9ef>def</span> ReshapeConstant : NativeCodeCall&lt;<span style=color:#e6db74>&#34;$0.reshape(($1.getType()).cast&lt;mlir::ShapedType&gt;())&#34;</span>&gt;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> FoldConstantReshapePattern : Pat &lt;
</span></span><span style=display:flex><span>	(ReshapeOp:$res (ConstantOp $arg)),
</span></span><span style=display:flex><span>	(ConstantOp (ReshapeConstant $arg, $res))&gt;;
</span></span></code></pre></div><p>After this we have to register these patterns into CanonicalizationPatterns Hook, this can be done via overriding function from Tablegen:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> mlir<span style=color:#f92672>::</span>gglow<span style=color:#f92672>::</span>ReshapeOp<span style=color:#f92672>::</span>getCanonicalizationPatterns(
</span></span><span style=display:flex><span>	mlir<span style=color:#f92672>::</span>RewritePatternSet <span style=color:#f92672>&amp;</span>results, mlir<span style=color:#f92672>::</span>MLIRContext <span style=color:#f92672>*</span>context)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	    results.add<span style=color:#f92672>&lt;</span>ReshapeReshapeOptPattern, RedundantReshapeOptPattern, 
</span></span><span style=display:flex><span>				    FoldConstantReshapePattern<span style=color:#f92672>&gt;</span>(context);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Running Canonicalization on the Parsed MLIR and getting the result IR.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>auto</span> module <span style=color:#f92672>=</span> mlir<span style=color:#f92672>::</span>parseSourceString<span style=color:#f92672>&lt;</span>mlir<span style=color:#f92672>::</span>ModuleOp<span style=color:#f92672>&gt;</span>(ir_content,
</span></span><span style=display:flex><span>													  <span style=color:#f92672>&amp;</span>context);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>module){
</span></span><span style=display:flex><span>	llvm<span style=color:#f92672>::</span>errs() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Failed to parse MLIR module</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>(enableOpt){
</span></span><span style=display:flex><span>	mlir<span style=color:#f92672>::</span>PassManager pm(module.get()<span style=color:#f92672>-&gt;</span>getName());
</span></span><span style=display:flex><span>	pm.addNestedPass<span style=color:#f92672>&lt;</span>mlir<span style=color:#f92672>::</span>func<span style=color:#f92672>::</span>FuncOp<span style=color:#f92672>&gt;</span>(mlir<span style=color:#f92672>::</span>createCanonicalizerPass());
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (mlir<span style=color:#f92672>::</span>failed(pm.run(<span style=color:#f92672>*</span>module)))
</span></span><span style=display:flex><span>		llvm<span style=color:#f92672>::</span>errs() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Failed to canonicalize</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>module<span style=color:#f92672>-&gt;</span>dump();
</span></span></code></pre></div><p>Finally this results in simplification of the following IR:
Source:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>auto</span> reshapeop_string <span style=color:#f92672>=</span> R<span style=color:#e6db74>&#34;(</span>
</span></span><span style=display:flex><span>	module {
</span></span><span style=display:flex><span>		func.func <span style=color:#960050;background-color:#1e0010>@</span>reshape_simplify() <span style=color:#f92672>-&gt;</span> tensor<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span>x1xf64<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>			<span style=color:#f92672>%</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>=</span> gglow.constant(dense<span style=color:#f92672>&lt;</span>[<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>2.0</span>]<span style=color:#f92672>&gt;</span> <span style=color:#f92672>:</span> tensor<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span>xf64<span style=color:#f92672>&gt;</span>) <span style=color:#f92672>-&gt;</span> tensor<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span>xf64<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>			<span style=color:#f92672>%</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>=</span> gglow.reshape (<span style=color:#f92672>%</span><span style=color:#ae81ff>0</span><span style=color:#f92672>:</span> tensor<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span>xf64<span style=color:#f92672>&gt;</span>) <span style=color:#f92672>-&gt;</span> tensor<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span>x1xf64<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>			<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>=</span> gglow.reshape (<span style=color:#f92672>%</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span> tensor<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span>x1xf64<span style=color:#f92672>&gt;</span>) <span style=color:#f92672>-&gt;</span> tensor<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span>x1xf64<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>			<span style=color:#f92672>%</span><span style=color:#ae81ff>3</span> <span style=color:#f92672>=</span> gglow.reshape (<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span><span style=color:#f92672>:</span> tensor<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span>x1xf64<span style=color:#f92672>&gt;</span>) <span style=color:#f92672>-&gt;</span> tensor<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span>x1xf64<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#f92672>%</span><span style=color:#ae81ff>3</span> <span style=color:#f92672>:</span> tensor<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span>x1xf64<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>)<span style=color:#e6db74>&#34;;</span>
</span></span></code></pre></div><p>Result:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span>module {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>func</span>.<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>@reshape_simplify</span>() -&gt; <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x1x</span><span style=color:#66d9ef>f64</span>&gt; {
</span></span><span style=display:flex><span>    %0 = gglow.<span style=color:#66d9ef>constant</span>(dense&lt;[[<span style=color:#ae81ff>1.000000e+00</span>], [<span style=color:#ae81ff>2.000000e+00</span>]]&gt; : <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x1x</span><span style=color:#66d9ef>f64</span>&gt;) -&gt; <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x1x</span><span style=color:#66d9ef>f64</span>&gt;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> %0 : <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x1x</span><span style=color:#66d9ef>f64</span>&gt;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1><ul><li>Canonicalization Wikipedia : <a href=https://en.wikipedia.org/wiki/Canonicalization>here</a></li><li>Dan Gohman article on Canonicalization : <a href=https://sunfishcode.github.io/blog/2018/10/22/Canonicalization.html>here</a></li><li>Toy Chapter 3 MLIR : <a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>here</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Gokul's Website</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>