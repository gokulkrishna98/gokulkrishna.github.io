<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>In-lining in MLIR | Gokul's Website</title>
<meta name=keywords content><meta name=description content="In the context of compilers, inlining or inline expansion is a process (or optimization depending on the use case) that replaces function call with the body of the function. Now let us see how we can inline a function defined in the IR.
Prerequisites
Before proceeding, I am implementing these features in my dialect Glow, please find more information here .
One of the main requirements is defining the function feature in the dialect, we will be utilizing traits and tablegen to implement these."><meta name=author content="Gokul"><link rel=canonical href=http://localhost:1313/posts/inlining/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/inlining/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/inlining/"><meta property="og:site_name" content="Gokul's Website"><meta property="og:title" content="In-lining in MLIR"><meta property="og:description" content="In the context of compilers, inlining or inline expansion is a process (or optimization depending on the use case) that replaces function call with the body of the function. Now let us see how we can inline a function defined in the IR.
Prerequisites Before proceeding, I am implementing these features in my dialect Glow, please find more information here .
One of the main requirements is defining the function feature in the dialect, we will be utilizing traits and tablegen to implement these."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-27T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-27T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="In-lining in MLIR"><meta name=twitter:description content="In the context of compilers, inlining or inline expansion is a process (or optimization depending on the use case) that replaces function call with the body of the function. Now let us see how we can inline a function defined in the IR.
Prerequisites
Before proceeding, I am implementing these features in my dialect Glow, please find more information here .
One of the main requirements is defining the function feature in the dialect, we will be utilizing traits and tablegen to implement these."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"In-lining in MLIR","item":"http://localhost:1313/posts/inlining/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"In-lining in MLIR","name":"In-lining in MLIR","description":"In the context of compilers, inlining or inline expansion is a process (or optimization depending on the use case) that replaces function call with the body of the function. Now let us see how we can inline a function defined in the IR.\nPrerequisites Before proceeding, I am implementing these features in my dialect Glow, please find more information here .\nOne of the main requirements is defining the function feature in the dialect, we will be utilizing traits and tablegen to implement these.\n","keywords":[],"articleBody":"In the context of compilers, inlining or inline expansion is a process (or optimization depending on the use case) that replaces function call with the body of the function. Now let us see how we can inline a function defined in the IR.\nPrerequisites Before proceeding, I am implementing these features in my dialect Glow, please find more information here .\nOne of the main requirements is defining the function feature in the dialect, we will be utilizing traits and tablegen to implement these.\n1. Function Operation This will represent a operation that will return a value. Since, MLIR provides nested structure of Region -\u003e Block -\u003e Operation -\u003e Region … , we can have a isolated set of computation represented by other operations and returns a value.\ndef FuncOp : GGlowOp\u003c\"func\", [FunctionOpInterface, IsolatedFromAbove]\u003e { let summary = \"user defined function operation\"; let description = [{ The \"gglow.func\" operation represents a user defined function. These are callable SSA-region operations that contain toy computations. Example: ``` gglow.func @main() { %0 = gglow.constant dense\u003c5.500000e+00\u003e : tensor %1 = gglow.reshape(%0 : tensor) -\u003e tensor\u003c2x2xf64\u003e gglow.print %1 : tensor\u003c2x2xf64\u003e gglow.return } ``` }]; let arguments = (ins SymbolNameAttr:$sym_name, TypeAttrOf:$function_type, OptionalAttr:$arg_attrs, OptionalAttr:$res_attrs ); let regions = (region AnyRegion:$body); let builders = [OpBuilder\u003c(ins \"StringRef\":$name, \"FunctionType\":$type, CArg\u003c\"ArrayRef\", \"{}\"\u003e:$attrs) \u003e]; let extraClassDeclaration = [{ /// Returns the argument types of this function. ArrayRef getArgumentTypes() { return getFunctionType().getInputs(); } /// Returns the result types of this function. ArrayRef getResultTypes() { return getFunctionType().getResults(); } Region *getCallableRegion() { return \u0026getBody(); } }]; let hasCustomAssemblyFormat = 1; let skipDefaultBuilders = 1; } Since we have mentioned it has customAssemblyFormat, we will be using custom printer parser which is implemented using some internal functions given by mlir (I am still trying to understand these…). You can find definition of these functions from here.\nvoid FuncOp::build(mlir::OpBuilder \u0026builder, mlir::OperationState \u0026state, llvm::StringRef name, mlir::FunctionType type, llvm::ArrayRef\u003cmlir::NamedAttribute\u003e attrs) { buildWithEntryBlock(builder, state, name, type, attrs, type.getInputs()); } mlir::ParseResult FuncOp::parse(mlir::OpAsmParser \u0026parser, mlir::OperationState \u0026result) { auto buildFuncType = [](mlir::Builder \u0026builder, llvm::ArrayRef\u003cmlir::Type\u003e argTypes, llvm::ArrayRef\u003cmlir::Type\u003e results, mlir::function_interface_impl::VariadicFlag, std::string \u0026) { return builder.getFunctionType(argTypes, results); }; return mlir::function_interface_impl::parseFunctionOp( parser, result, /*allowVariadic=*/false, getFunctionTypeAttrName(result.name), buildFuncType, getArgAttrsAttrName(result.name), getResAttrsAttrName(result.name)); } void FuncOp::print(mlir::OpAsmPrinter \u0026p) { mlir::function_interface_impl::printFunctionOp( p, *this, /*isVariadic=*/false, getFunctionTypeAttrName(), getArgAttrsAttrName(), getResAttrsAttrName()); } The only main thing we have to concern ourselves with are the two traits used:\nFunctionOpInterface: It provides types, methods and data structures needed to implement function operation. (no documentation found :/) IsolatedFromAbove: This trait makes the symbols defined within function invisible to the parent regions it is part of. Read more here 2. Return Operation The Block inside the function operation encapsulates all the computation (via other operations). To keep things simple (like a C++ function), it has one SSA - Control Flow Graph region, where there are multiple blocks. The instruction inside this block is executed in-order and each block has a termination operator which transfers control to other blocks.\nWhy am I explaining this ? It is because the return operation is our termination operator that transfer control to other block.\ndef ReturnOp : GGlowOp\u003c\"return\", [Pure, HasParent\u003c\"FuncOp\"\u003e, Terminator]\u003e { let summary = \"return operation\"; let description = [{ The \"return\" operation represents a return operation within a function. The operation takes an optional tensor operand and produces no results. The operand type must match the signature of the function that contains the operation. For example: ``` gglow.func @foo() -\u003e tensor\u003c2xf64\u003e { ... gglow.return %0 : tensor\u003c2xf64\u003e } ``` }]; let arguments = (ins Variadic:$input); let assemblyFormat = \"($input^ `:` type($input))? attr-dict \"; let builders = [ OpBuilder\u003c(ins), [{ build($_builder, $_state, std::nullopt); }]\u003e ]; let extraClassDeclaration = [{ bool hasOperand() { return getNumOperands() != 0; } }]; } The only part we have to concern ourselves are the traits used:\nHasParent\u003c\"FuncOp\"\u003e: This tells us that the return operation is child operator to FuncOp which we defined before and provides API and verifiers needed for such operations. Read more from here Terminator: This trait provides verification and functionality for operations that are known to be terminators . 3. Call Operation This is basically an operation that calls the function defined. Here we define the function to take in only F64Tensors as arguments (but this can be made much more extensive)\ndef GenericCallOp : GGlowOp \u003c\"generic_call\", [DeclareOpInterfaceMethods]\u003e { let summary = \"generic call operation\"; let description = [{ Generic calls represent calls to a user defined function that needs to be specialized for the shape of its arguments. The callee name is attached as a symbol reference via an attribute. The arguments list must match the arguments expected by the callee. For example: ```mlir %4 = gglow.generic_call @my_func(%1, %3) : (tensor\u003c2x3xf64\u003e, tensor\u003c2x3xf64\u003e) -\u003e tensor\u003c*xf64\u003e ``` This is only valid if a function named \"my_func\" exists and takes two arguments. }]; let arguments = (ins FlatSymbolRefAttr:$callee, Variadic:$inputs); let results = (outs F64Tensor); let assemblyFormat = [{ $callee `(` $inputs `)` attr-dict `:` functional-type($inputs, results) }]; let builders = [ OpBuilder\u003c(ins \"StringRef\":$callee, \"ArrayRef\":$arguments)\u003e ]; } Defining the Inline Implementation using MLIR Interface We can just use a wrapper provided by MLIR called DialectInlinerInterface. This class which implements in-lining feature by deriving it from base-class using CRTP (Curiously Recursive Template Pattern), this allows us to make inheritance go backward and allow parent classes to use the instance of derived class members. definition:\nclass DialectInlinerInterface : public DialectInterface::Base\u003cDialectInlinerInterface\u003e { // body of the class } Now, we define the following (based of toy chapter 4):\nstruct GGlowInlinerInterface : public DialectInlinerInterface { using DialectInlinerInterface::DialectInlinerInterface; bool isLegalToInline(Operation *call, Operation *callable, bool wouldBeCloned) const final { return true; } bool isLegalToInline(Operation *, Region *, bool, IRMapping \u0026) const final { return true; } bool isLegalToInline(Region *, Region *, bool, IRMapping \u0026) const final { return true; } void handleTerminator(Operation *op, ValueRange valuesToRepl) const final { auto returnOp = cast\u003cReturnOp\u003e(op); assert(returnOp.getNumOperands() == valuesToRepl.size()); for (const auto \u0026it : llvm::enumerate(returnOp.getOperands())) valuesToRepl[it.index()].replaceAllUsesWith(it.value()); } }; I will update the working of handle-terminator later. Later we have to register this interface and then enable the in-lining pass via Pass manager\nvoid GlowDialect::initialize() { addOperations\u003c #define GET_OP_LIST #include \"lib/Dialect/GGlow/GGlowOps.cpp.inc\" \u003e(); addInterface\u003cGGlowInlinerInterface\u003e(); } mlir::PassManager pm(module.get()-\u003egetName()); pm.addPass(mlir::createInlinerPass()); Result From the above implementation, we can achieve following transformation of IR\nmodule { gglow.func @transpose_simplify() -\u003e tensor\u003c2x3xf64\u003e { %0 = gglow.constant ( dense\u003c[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]\u003e : tensor\u003c2x3xf64\u003e ) -\u003e tensor\u003c2x3xf64\u003e %1 = gglow.transpose (%0: tensor\u003c2x3xf64\u003e) -\u003e tensor\u003c3x2xf64\u003e %2 = gglow.transpose (%1: tensor\u003c3x2xf64\u003e) -\u003e tensor\u003c2x3xf64\u003e gglow.return %2 : tensor\u003c2x3xf64\u003e } gglow.func @main() { %0 = gglow.generic_call @transpose_simplify() : () -\u003e tensor\u003c2x3xf64\u003e gglow.print %0 : tensor\u003c2x3xf64\u003e gglow.return } } to\nmodule { gglow.func @transpose_simplify() -\u003e tensor\u003c2x3xf64\u003e { %0 = gglow.constant(dense\u003c[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]\u003e : tensor\u003c2x3xf64\u003e) -\u003e tensor\u003c2x3xf64\u003e gglow.return %0 : tensor\u003c2x3xf64\u003e } gglow.func @main() { %0 = gglow.constant(dense\u003c[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]\u003e : tensor\u003c2x3xf64\u003e) -\u003e tensor\u003c2x3xf64\u003e gglow.print %0 : tensor\u003c2x3xf64\u003e gglow.return } } ","wordCount":"1124","inLanguage":"en","datePublished":"2024-08-27T00:00:00Z","dateModified":"2024-08-27T00:00:00Z","author":{"@type":"Person","name":"Gokul"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/inlining/"},"publisher":{"@type":"Organization","name":"Gokul's Website","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Gokul's Website (Alt + H)">Gokul's Website</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">In-lining in MLIR</h1><div class=post-meta><span title='2024-08-27 00:00:00 +0000 UTC'>August 27, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1124 words&nbsp;·&nbsp;Gokul</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-function-operation>1. Function Operation</a></li><li><a href=#2-return-operation>2. Return Operation</a></li><li><a href=#3-call-operation>3. Call Operation</a></li><li><a href=#defining-the-inline-implementation-using-mlir-interface>Defining the Inline Implementation using MLIR Interface</a></li></ul></nav></div></details></div><div class=post-content><p>In the context of compilers, <code>inlining or inline expansion</code> is a process (or optimization depending on the use case) that replaces function call with the body of the function. Now let us see how we can inline a function defined in the IR.</p><h1 id=prerequisites>Prerequisites<a hidden class=anchor aria-hidden=true href=#prerequisites>#</a></h1><p>Before proceeding, I am implementing these features in my dialect Glow, please find more information <a href=https://github.com/gokulkrishna98/GGlow/tree/main/lib/Dialect/GGlow>here</a> .</p><p>One of the main requirements is defining the function feature in the dialect, we will be utilizing traits and tablegen to implement these.</p><h2 id=1-function-operation>1. Function Operation<a hidden class=anchor aria-hidden=true href=#1-function-operation>#</a></h2><p>This will represent a operation that will return a value. Since, MLIR provides nested structure of Region -> Block -> Operation -> Region &mldr; , we can have a isolated set of computation represented by other operations and returns a value.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tablegen data-lang=tablegen><span style=display:flex><span><span style=color:#66d9ef>def</span> FuncOp : GGlowOp&lt;<span style=color:#e6db74>&#34;func&#34;</span>, [FunctionOpInterface, IsolatedFromAbove]&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> summary = <span style=color:#e6db74>&#34;user defined function operation&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> description = <span style=color:#e6db74>[{
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        The &#34;gglow.func&#34; operation represents a user defined function. These are
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        callable SSA-region operations that contain toy computations.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Example:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ```
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        gglow.func @main() {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        %0 = gglow.constant dense&lt;5.500000e+00&gt; : tensor&lt;f64&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        %1 = gglow.reshape(%0 : tensor&lt;f64&gt;) -&gt; tensor&lt;2x2xf64&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        gglow.print %1 : tensor&lt;2x2xf64&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        gglow.return
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ```
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> arguments = (ins
</span></span><span style=display:flex><span>        SymbolNameAttr:$sym_name,
</span></span><span style=display:flex><span>        TypeAttrOf&lt;FunctionType&gt;:$function_type,
</span></span><span style=display:flex><span>        OptionalAttr&lt;DictArrayAttr&gt;:$arg_attrs,
</span></span><span style=display:flex><span>        OptionalAttr&lt;DictArrayAttr&gt;:$res_attrs
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> regions = (region AnyRegion:$body);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> builders = [OpBuilder&lt;(ins
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;StringRef&#34;</span>:$name, <span style=color:#e6db74>&#34;FunctionType&#34;</span>:$type,
</span></span><span style=display:flex><span>        CArg&lt;<span style=color:#e6db74>&#34;ArrayRef&lt;NamedAttribute&gt;&#34;</span>, <span style=color:#e6db74>&#34;{}&#34;</span>&gt;:$attrs)
</span></span><span style=display:flex><span>    &gt;];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> extraClassDeclaration = <span style=color:#e6db74>[{
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        /// Returns the argument types of this function.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ArrayRef&lt;Type&gt; getArgumentTypes() { return getFunctionType().getInputs(); }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        /// Returns the result types of this function.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ArrayRef&lt;Type&gt; getResultTypes() { return getFunctionType().getResults(); }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Region *getCallableRegion() { return &amp;getBody(); }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> hasCustomAssemblyFormat = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> skipDefaultBuilders = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since we have mentioned it has customAssemblyFormat, we will be using custom printer parser which is implemented using some internal functions given by mlir (I am still trying to understand these&mldr;). You can find definition of these functions from <a href=https://mlir.llvm.org/doxygen/FunctionInterfaces_8h_source.html>here</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> FuncOp<span style=color:#f92672>::</span>build(mlir<span style=color:#f92672>::</span>OpBuilder <span style=color:#f92672>&amp;</span>builder, mlir<span style=color:#f92672>::</span>OperationState <span style=color:#f92672>&amp;</span>state,
</span></span><span style=display:flex><span>                   llvm<span style=color:#f92672>::</span>StringRef name, mlir<span style=color:#f92672>::</span>FunctionType type,
</span></span><span style=display:flex><span>                   llvm<span style=color:#f92672>::</span>ArrayRef<span style=color:#f92672>&lt;</span>mlir<span style=color:#f92672>::</span>NamedAttribute<span style=color:#f92672>&gt;</span> attrs)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    buildWithEntryBlock(builder, state, name, type, attrs, type.getInputs());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mlir<span style=color:#f92672>::</span>ParseResult FuncOp<span style=color:#f92672>::</span>parse(mlir<span style=color:#f92672>::</span>OpAsmParser <span style=color:#f92672>&amp;</span>parser,
</span></span><span style=display:flex><span>                                mlir<span style=color:#f92672>::</span>OperationState <span style=color:#f92672>&amp;</span>result)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> buildFuncType <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        [](mlir<span style=color:#f92672>::</span>Builder <span style=color:#f92672>&amp;</span>builder, llvm<span style=color:#f92672>::</span>ArrayRef<span style=color:#f92672>&lt;</span>mlir<span style=color:#f92672>::</span>Type<span style=color:#f92672>&gt;</span> argTypes,
</span></span><span style=display:flex><span>           llvm<span style=color:#f92672>::</span>ArrayRef<span style=color:#f92672>&lt;</span>mlir<span style=color:#f92672>::</span>Type<span style=color:#f92672>&gt;</span> results,
</span></span><span style=display:flex><span>           mlir<span style=color:#f92672>::</span>function_interface_impl<span style=color:#f92672>::</span>VariadicFlag,
</span></span><span style=display:flex><span>           std<span style=color:#f92672>::</span>string <span style=color:#f92672>&amp;</span>)
</span></span><span style=display:flex><span>    { <span style=color:#66d9ef>return</span> builder.getFunctionType(argTypes, results); };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> mlir<span style=color:#f92672>::</span>function_interface_impl<span style=color:#f92672>::</span>parseFunctionOp(
</span></span><span style=display:flex><span>        parser, result, <span style=color:#75715e>/*allowVariadic=*/</span>false,
</span></span><span style=display:flex><span>        getFunctionTypeAttrName(result.name), buildFuncType,
</span></span><span style=display:flex><span>        getArgAttrsAttrName(result.name), getResAttrsAttrName(result.name));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> FuncOp<span style=color:#f92672>::</span>print(mlir<span style=color:#f92672>::</span>OpAsmPrinter <span style=color:#f92672>&amp;</span>p)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    mlir<span style=color:#f92672>::</span>function_interface_impl<span style=color:#f92672>::</span>printFunctionOp(
</span></span><span style=display:flex><span>        p, <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>, <span style=color:#75715e>/*isVariadic=*/</span>false, getFunctionTypeAttrName(),
</span></span><span style=display:flex><span>        getArgAttrsAttrName(), getResAttrsAttrName());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The only main thing we have to concern ourselves with are the two traits used:</p><ul><li><code>FunctionOpInterface</code>: It provides types, methods and data structures needed to implement function operation. (no documentation found :/)</li><li><code>IsolatedFromAbove</code>: This trait makes the symbols defined within function invisible to the parent regions it is part of. Read more <a href=https://mlir.llvm.org/docs/Traits/#isolatedfromabove>here</a></li></ul><h2 id=2-return-operation>2. Return Operation<a hidden class=anchor aria-hidden=true href=#2-return-operation>#</a></h2><p>The Block inside the function operation encapsulates all the computation (via other operations). To keep things simple (like a C++ function), it has one SSA - Control Flow Graph region, where there are multiple blocks. The instruction inside this block is executed in-order and each block has a termination operator which transfers control to other blocks.</p><p>Why am I explaining this ? It is because the return operation is our termination operator that transfer control to other block.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tablegen data-lang=tablegen><span style=display:flex><span><span style=color:#66d9ef>def</span> ReturnOp : GGlowOp&lt;<span style=color:#e6db74>&#34;return&#34;</span>, [Pure, HasParent&lt;<span style=color:#e6db74>&#34;FuncOp&#34;</span>&gt;,
</span></span><span style=display:flex><span>                                 Terminator]&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> summary = <span style=color:#e6db74>&#34;return operation&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> description = <span style=color:#e6db74>[{
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        The &#34;return&#34; operation represents a return operation within a function.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        The operation takes an optional tensor operand and produces no results.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        The operand type must match the signature of the function that contains
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        the operation. For example:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ```
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            gglow.func @foo() -&gt; tensor&lt;2xf64&gt; {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            ...
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            gglow.return %0 : tensor&lt;2xf64&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ```
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> arguments = (ins Variadic&lt;F64Tensor&gt;:$input);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> assemblyFormat = <span style=color:#e6db74>&#34;($input^ `:` type($input))? attr-dict &#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> builders = [
</span></span><span style=display:flex><span>        OpBuilder&lt;(ins), <span style=color:#e6db74>[{ build($_builder, $_state, std::nullopt); }]</span>&gt;
</span></span><span style=display:flex><span>    ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> extraClassDeclaration = <span style=color:#e6db74>[{
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        bool hasOperand() { return getNumOperands() != 0; }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The only part we have to concern ourselves are the traits used:</p><ul><li><code>HasParent&lt;"FuncOp"></code>: This tells us that the return operation is child operator to <code>FuncOp</code> which we defined before and provides API and verifiers needed for such operations. Read more from <a href=https://mlir.llvm.org/docs/Traits/#hasparent>here</a></li><li><code>Terminator</code>: This trait provides verification and functionality for operations that are known to be <a href=https://mlir.llvm.org/docs/LangRef/#control-flow-and-ssacfg-regions>terminators</a> .</li></ul><h2 id=3-call-operation>3. Call Operation<a hidden class=anchor aria-hidden=true href=#3-call-operation>#</a></h2><p>This is basically an operation that calls the function defined. Here we define the function to take in only <code>F64Tensors</code> as arguments (but this can be made much more extensive)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tablegen data-lang=tablegen><span style=display:flex><span><span style=color:#66d9ef>def</span> GenericCallOp : GGlowOp &lt;<span style=color:#e6db74>&#34;generic_call&#34;</span>, [DeclareOpInterfaceMethods&lt;CallOpInterface&gt;]&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> summary = <span style=color:#e6db74>&#34;generic call operation&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> description = <span style=color:#e6db74>[{
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Generic calls represent calls to a user defined function that needs to
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        be specialized for the shape of its arguments. The callee name is attached
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        as a symbol reference via an attribute. The arguments list must match the
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        arguments expected by the callee. For example:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ```mlir
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        %4 = gglow.generic_call @my_func(%1, %3)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            : (tensor&lt;2x3xf64&gt;, tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ```
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        This is only valid if a function named &#34;my_func&#34; exists and takes two
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        arguments.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> arguments = (ins FlatSymbolRefAttr:$callee, Variadic&lt;F64Tensor&gt;:$inputs);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> results = (outs F64Tensor);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> assemblyFormat = <span style=color:#e6db74>[{
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        $callee `(` $inputs `)` attr-dict `:` functional-type($inputs, results)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }]</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> builders = [
</span></span><span style=display:flex><span>        OpBuilder&lt;(ins <span style=color:#e6db74>&#34;StringRef&#34;</span>:$callee, <span style=color:#e6db74>&#34;ArrayRef&lt;Value&gt;&#34;</span>:$arguments)&gt;
</span></span><span style=display:flex><span>    ];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=defining-the-inline-implementation-using-mlir-interface>Defining the Inline Implementation using MLIR Interface<a hidden class=anchor aria-hidden=true href=#defining-the-inline-implementation-using-mlir-interface>#</a></h2><p>We can just use a wrapper provided by MLIR called <code>DialectInlinerInterface</code>. This class which implements in-lining feature by deriving it from base-class using <code>CRTP</code> (Curiously Recursive Template Pattern), this allows us to make inheritance go backward and allow parent classes to use the instance of derived class members.
definition:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DialectInlinerInterface</span>
</span></span><span style=display:flex><span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> DialectInterface<span style=color:#f92672>::</span>Base<span style=color:#f92672>&lt;</span>DialectInlinerInterface<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// body of the class
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Now, we define the following (based of toy chapter 4):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>GGlowInlinerInterface</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> DialectInlinerInterface {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> DialectInlinerInterface<span style=color:#f92672>::</span>DialectInlinerInterface;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isLegalToInline</span>(Operation <span style=color:#f92672>*</span>call, Operation <span style=color:#f92672>*</span>callable,
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>bool</span> wouldBeCloned) <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>final</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isLegalToInline</span>(Operation <span style=color:#f92672>*</span>, Region <span style=color:#f92672>*</span>, <span style=color:#66d9ef>bool</span>, IRMapping <span style=color:#f92672>&amp;</span>) <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>final</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isLegalToInline</span>(Region <span style=color:#f92672>*</span>, Region <span style=color:#f92672>*</span>, <span style=color:#66d9ef>bool</span>, IRMapping <span style=color:#f92672>&amp;</span>) <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>final</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleTerminator</span>(Operation <span style=color:#f92672>*</span>op, ValueRange valuesToRepl) <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>final</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> returnOp <span style=color:#f92672>=</span> cast<span style=color:#f92672>&lt;</span>ReturnOp<span style=color:#f92672>&gt;</span>(op);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assert(returnOp.getNumOperands() <span style=color:#f92672>==</span> valuesToRepl.size());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>it : llvm<span style=color:#f92672>::</span>enumerate(returnOp.getOperands()))
</span></span><span style=display:flex><span>            valuesToRepl[it.index()].replaceAllUsesWith(it.value());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>I will update the working of handle-terminator later. Later we have to register this interface and then enable the in-lining pass via Pass manager</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> GlowDialect<span style=color:#f92672>::</span>initialize()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    addOperations<span style=color:#f92672>&lt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#define GET_OP_LIST
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;lib/Dialect/GGlow/GGlowOps.cpp.inc&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    addInterface<span style=color:#f92672>&lt;</span>GGlowInlinerInterface<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>mlir<span style=color:#f92672>::</span>PassManager pm(module.get()<span style=color:#f92672>-&gt;</span>getName());
</span></span><span style=display:flex><span>pm.addPass(mlir<span style=color:#f92672>::</span>createInlinerPass());
</span></span></code></pre></div><h1 id=result>Result<a hidden class=anchor aria-hidden=true href=#result>#</a></h1><p>From the above implementation, we can achieve following transformation of IR</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span>module {
</span></span><span style=display:flex><span>	gglow.<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>@transpose_simplify</span>() -&gt; <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x3x</span><span style=color:#66d9ef>f64</span>&gt; {
</span></span><span style=display:flex><span>		%0 = gglow.<span style=color:#66d9ef>constant</span> ( dense&lt;[[<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>2.0</span>, <span style=color:#ae81ff>3.0</span>], [<span style=color:#ae81ff>4.0</span>, <span style=color:#ae81ff>5.0</span>, <span style=color:#ae81ff>6.0</span>]]&gt;
</span></span><span style=display:flex><span>			: <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x3x</span><span style=color:#66d9ef>f64</span>&gt; ) -&gt; <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x3x</span><span style=color:#66d9ef>f64</span>&gt;
</span></span><span style=display:flex><span>		%1 = gglow.transpose (%0: <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x3x</span><span style=color:#66d9ef>f64</span>&gt;) -&gt; <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>3x2x</span><span style=color:#66d9ef>f64</span>&gt;
</span></span><span style=display:flex><span>		%2 = gglow.transpose (%1: <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>3x2x</span><span style=color:#66d9ef>f64</span>&gt;) -&gt; <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x3x</span><span style=color:#66d9ef>f64</span>&gt;
</span></span><span style=display:flex><span>		gglow.<span style=color:#66d9ef>return</span> %2 : <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x3x</span><span style=color:#66d9ef>f64</span>&gt;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	gglow.<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>@main</span>() {
</span></span><span style=display:flex><span>		%0 = gglow.generic_call <span style=color:#a6e22e>@transpose_simplify</span>() : () -&gt; <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x3x</span><span style=color:#66d9ef>f64</span>&gt;
</span></span><span style=display:flex><span>		gglow.print %0 : <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x3x</span><span style=color:#66d9ef>f64</span>&gt;
</span></span><span style=display:flex><span>		gglow.<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>to</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span>module {
</span></span><span style=display:flex><span>  gglow.<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>@transpose_simplify</span>() -&gt; <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x3x</span><span style=color:#66d9ef>f64</span>&gt; {
</span></span><span style=display:flex><span>    %0 = gglow.<span style=color:#66d9ef>constant</span>(dense&lt;[[<span style=color:#ae81ff>1.000000e+00</span>, <span style=color:#ae81ff>2.000000e+00</span>, <span style=color:#ae81ff>3.000000e+00</span>], [<span style=color:#ae81ff>4.000000e+00</span>, <span style=color:#ae81ff>5.000000e+00</span>, <span style=color:#ae81ff>6.000000e+00</span>]]&gt; : <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x3x</span><span style=color:#66d9ef>f64</span>&gt;) -&gt; <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x3x</span><span style=color:#66d9ef>f64</span>&gt;
</span></span><span style=display:flex><span>    gglow.<span style=color:#66d9ef>return</span> %0 : <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x3x</span><span style=color:#66d9ef>f64</span>&gt;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  gglow.<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>@main</span>() {
</span></span><span style=display:flex><span>    %0 = gglow.<span style=color:#66d9ef>constant</span>(dense&lt;[[<span style=color:#ae81ff>1.000000e+00</span>, <span style=color:#ae81ff>2.000000e+00</span>, <span style=color:#ae81ff>3.000000e+00</span>], [<span style=color:#ae81ff>4.000000e+00</span>, <span style=color:#ae81ff>5.000000e+00</span>, <span style=color:#ae81ff>6.000000e+00</span>]]&gt; : <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x3x</span><span style=color:#66d9ef>f64</span>&gt;) -&gt; <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x3x</span><span style=color:#66d9ef>f64</span>&gt;
</span></span><span style=display:flex><span>    gglow.print %0 : <span style=color:#66d9ef>tensor</span>&lt;<span style=color:#ae81ff>2x3x</span><span style=color:#66d9ef>f64</span>&gt;
</span></span><span style=display:flex><span>    gglow.<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Gokul's Website</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>